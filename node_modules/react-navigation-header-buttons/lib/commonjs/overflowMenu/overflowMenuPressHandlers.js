"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.overflowMenuPressHandlerPopupMenu = exports.overflowMenuPressHandlerDropdownMenu = exports.overflowMenuPressHandlerActionSheet = exports.extractOverflowButtonData = exports.extractHiddenItemProps = exports.defaultOnOverflowMenuPress = void 0;
var _reactNative = require("react-native");
var _HeaderItems = require("../HeaderItems");
var _reactToImperative = _interopRequireDefault(require("react-to-imperative"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const extractOverflowButtonData = hiddenButtons => {
  return (0, _reactToImperative.default)(hiddenButtons, extractHiddenItemProps);
};
exports.extractOverflowButtonData = extractOverflowButtonData;
const extractHiddenItemProps = _ref => {
  let {
    props,
    type
  } = _ref;
  if (type === _HeaderItems.HiddenItem) {
    return props;
  }
  return true;
};
exports.extractHiddenItemProps = extractHiddenItemProps;
const overflowMenuPressHandlerActionSheet = _ref2 => {
  let {
    hiddenButtons,
    cancelButtonLabel = 'Cancel'
  } = _ref2;
  let actionTitles = hiddenButtons.map(btn => btn.title);
  actionTitles.unshift(cancelButtonLabel);
  const disabledButtonIndices = (() => {
    let result = [];
    hiddenButtons.forEach((it, index) => {
      if (it.disabled) {
        result.push(index + 1);
      }
    });
    return result;
  })();
  const destructiveButtonIndex = (() => {
    let result = [];
    hiddenButtons.forEach((it, index) => {
      if (it.destructive) {
        result.push(index + 1);
      }
    });
    return result;
  })();
  _reactNative.ActionSheetIOS.showActionSheetWithOptions({
    options: actionTitles,
    cancelButtonIndex: 0,
    disabledButtonIndices,
    destructiveButtonIndex
  }, buttonIndex => {
    if (buttonIndex > 0) {
      var _hiddenButtons, _hiddenButtons$onPres;
      (_hiddenButtons = hiddenButtons[buttonIndex - 1]) === null || _hiddenButtons === void 0 ? void 0 : (_hiddenButtons$onPres = _hiddenButtons.onPress) === null || _hiddenButtons$onPres === void 0 ? void 0 : _hiddenButtons$onPres.call(_hiddenButtons);
    }
  });
};
exports.overflowMenuPressHandlerActionSheet = overflowMenuPressHandlerActionSheet;
const overflowMenuPressHandlerPopupMenu = _ref3 => {
  let {
    hiddenButtons,
    overflowButtonRef
  } = _ref3;
  const enabledButtons = hiddenButtons.filter(it => it.disabled !== true);
  const presenter = _reactNative.UIManager.showPopupMenu;
  const node = (0, _reactNative.findNodeHandle)(overflowButtonRef);
  if (!presenter || !node) {
    console.warn('could not present overflow menu');
    return;
  }
  presenter(node, enabledButtons.map(btn => btn.title), () => console.debug('overflowBtn error'), (eventName, index) => {
    var _enabledButtons$index, _enabledButtons$index2;
    if (eventName !== 'itemSelected' || typeof index !== 'number') {
      return;
    }
    (_enabledButtons$index = enabledButtons[index]) === null || _enabledButtons$index === void 0 ? void 0 : (_enabledButtons$index2 = _enabledButtons$index.onPress) === null || _enabledButtons$index2 === void 0 ? void 0 : _enabledButtons$index2.call(_enabledButtons$index);
  });
};
exports.overflowMenuPressHandlerPopupMenu = overflowMenuPressHandlerPopupMenu;
const overflowMenuPressHandlerDropdownMenu = _ref4 => {
  let {
    children,
    overflowButtonRef,
    _private_toggleMenu
  } = _ref4;
  if (overflowButtonRef) {
    overflowButtonRef.measureInWindow((x, y, width) => {
      _private_toggleMenu({
        elements: children,
        x: x + width,
        y
      });
    });
  } else {
    console.error('overflowButtonRef is null, cannot show overflow menu');
  }
};
exports.overflowMenuPressHandlerDropdownMenu = overflowMenuPressHandlerDropdownMenu;
const defaultOnOverflowMenuPress = _reactNative.Platform.select({
  ios: overflowMenuPressHandlerActionSheet,
  default: overflowMenuPressHandlerDropdownMenu
});
exports.defaultOnOverflowMenuPress = defaultOnOverflowMenuPress;
//# sourceMappingURL=overflowMenuPressHandlers.js.map